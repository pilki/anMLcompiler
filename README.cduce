This package is a modified distribution of OCaml 3.08.2 with
extensions to deal with set-theoretic types.

It is distributed under the same licenses as Objective Caml: the Q
Public License version 1.0 for the Compiler, and the LPLG version 2
for the Library.


DATA MODEL:

The extension introduces a new kind of values and types, called
x-types and x-values (x as extensional). An x-value can be:

- an (arbitrarily large) integer;
- a Unicode codepoint;
- a qualified name, made of a namespace URI and a local name;
- a pair of x-values;
- a record (finite mapping from labels to x-values, where
  labels are qualified names);
- a triple of x-values, called an x-element.

Syntactic sugar is provided to deal with sequences of x-values. They
are nothing but nested pairs with `nil as terminator (`nil
is the qualified name with an empty namespace URI and "nil" as
local name).


X-EXPRESSIONS:

The extension introduces x-expressions (they don't necessarily evaluate
to x-values). An x-expression E can be used in an OCaml expression
by putting double-braces around {{ E }}. Similarly, an OCaml expression e
can be used in an x-expression by writting {{ e }}; this is useful
to use general-purpose OCaml features in x-expression (e.g.
if-then-else, loops, exceptions, ...).

X-expressions follows special lexical conventions.

Integer literals are a valid x-expressions. Arbitrarily
large integer literals are allowed. Negative literals must be in
parenthesis. E.g. (-3).

Characters literals are delimited by single quotes. The escape
sequences \n, \r, \t, \b, \', \", \\ are recognized as usual.  The
numerical escape sequence are written \n; where n is an integer
literal. The source is interpreted as being encoded in iso-8859-1.

String literals are delimited by double quotes. The content follows
the same convention as for character literals. In fact, an x-string
is just a sequence a characters (see below for the definition of sequences).

The extension imports the notion of namespace prefixes as defined
in the XML Namespaces specification. Prefixes are OCaml identifiers. 
They are bound to an arbitrary x-string. A special structure item
is used to do this binding:
  {{ namespace prefix = "..." }}
This can also appear in a module interface. The scope of the prefix binding
is only the current structure or signature; it is not exported.
It is also possible to specify a default namespace:
  {{ namespace "..." }}
The default namespace can be reset with:
  {{ namespace "" }}
There are also x-expressions to create local bindings:
  let namespace prefix = "..." in ...
  let namespace "..." in ...

Qualified name literals are made of a namespace and a localname. They
are prefixed with a backquote. The namespace is referred to by an
optional prefix (when no prefix is given, the default namespace
applies). The possible syntax are thus:
  `prefix:ncname
  `ncname
ncname stands for non-colon name; cf XML Namespaces for a definition.
It is possible to use special Unicode characters in ncnames, e.g.:
  `A\2544;B
is a ncname of length 3. A dot character in an ncname must be
escaped with a backslash.

A qualified OCaml identifier is an x-expression. It does not need to be
escaped with {{...}}.

Tuple of x-expressions: (E1,...,En), which is equivalent to the nested
pair (E1,(...,En)...).

Sequence of x-expressions: [ E1 ... En ], which is equivalent to the nested
pair (E1,...(En,`nil)). Each component Ei can also be !E where
E is an x-expression; this means that E is itself a sequence,
whose contents must be inserted into the new sequence.
A component can also be a string literal delimited with simple
quotes '...' which is equivalent to !"...". In particular, all
the following denote the same value:
  "abc"
  [ 'a' 'b' 'c' ]
  [ 'abc' ]
  [ !"ab" 'c' ]

Concatenation of x-sequences: E1 @ E2, which is equivalent to [ !E1 !E2 ].

Records: { l1=E1 ... ln=En }. The li are labels; they have
the same syntax as qualified names without the leading backquote. However, if
the namespace prefix is not given, the default prefix does not apply
(the namespace URI is empty). Fields can also be separated with a semi-colon.
It is legal to omit the =E part of a field; the label is then
taken as the content of the field. E.g.:
   let x = ... in 
   let y = ... in
   { x y z=3 }  (* equivalent to { x=x y=y z=3 } *)

X-elements: <tag attribs>E. tag is a qualified name without the leading
backquote or an x-expression between parenthesis (E). attribs has the same
syntax as record fields (without the braces). It can also be an
x-expression between parenthesis (E). 

Infix arithmethic operators: +,*,-,div,mod.

Field access: E . l
  E can be a record or an XML element.
  Equivalent to:
   match E with { l=x .. } | <_ l=x ..>_ -> x

Optional field access: E .? l
  Equivalent to:
   match E with { l=x .. } | <_ l=x ..>_ -> [x] | _ -> []

Children: E/
  Equivalent to:
    map E with <_ _>x -> x | _ -> []
  
Filtering: E.(t)
  Equivalent to:
    match E with [ (x::t | _)* ] -> x



Field removal: E -. l

Record concatenation: E1 + E2  (fields in E2 are used in case of conflict).
(note that + is overloaded)

Dynamic type-check: E :? T where T is an x-type. Returns
the result of E if it has type T, otherwise raises a Failure
exception whose content explains why it isn't the case.

Pattern-matching:  match E with P1 -> E1 | ... | Pn -> En.
Each Pi is an x-patterns; its capture variables are bound in Ei.
The type-system ensures exhaustivivity of the pattern-matching.
It is also possile to use x-pattern matching as a regular
OCaml expression; patterns must be surrounded by {{..}}, e.g.:
   match e with {{P1}} -> e1 | ... | {{Pn}} -> en
   function {{P1}} -> e1 | ... | {{Pn}} -> en


Local-binding: let P=E1 in E2, equivalent to match E1 with P -> E2.
In OCaml expressions: let {{P}}=e1 in e2

Sequence iterator: map E with P1 -> E1 | ... | Pn -> En.
E must evaluate to a sequence. Each of the elements are then
transformed by the branches (they must all return a sequence). E.g.:
   map [ 1 2 3 ] with x -> [ (x+1) (x+2) ]

Tree iterator: map* E with P1 -> E1 | ... | Pn -> En.
E must evaluate to a sequence. Each of the elements are then
transformed by the branches (they must all return a sequence).
If an element is not matched; it is just copied in the result
unless it is an x-element <tag attrs>V. In this case, the transformation
is applied recursively to its content V (which must be a sequence).

Local namespace binding: 
   let namespace prefix = "..." in E   (defines prefix)
   let namespace "..." in E            (defines default namespace)

Function application:
   E1 E2

Translating from an OCaml value: {: e :} 
The type of e must be
monomorphic. Other restrictions apply (abstract types, objects,
functions, are not accepted).

It is also possible to translate from an x-value back to an OCaml
value. The syntax is {: E :} (this is an OCaml expression,
E is an x-expression). The resulting type must be constrained
enough to satisfy the same constraints as above.

X-TYPES:

X-values have very precise x-types. As a matter of fact,
a literal x-value is also a valid x-type which contains
only this value. X-types are monomorphic: they cannot contain
type variables.

An x-type T can be used as an OCaml type with the notation {{ T }}.

In general, X-types denote set of values. Set-theoretic operations
are available:

Union of x-types: T1 | T2
Intersection of x-types: T1 & T2
Difference of x-types: T1 - T2

Cartesian product: (T1,...,Tn), equivalent to the nested product
(T1,(...,Tn)...).

Record type: { li=T1 ... ln=Tn }. Fields can be separated with an optional
semi-colon. This type contains x-records with exactly the fields
l1,...,ln (with the correct type). It is possible to make one of
the fields optional by changing = to =?. It is also possible
to allow any extra field by adding .. after the fields.

Any-in-namespace:  the type `prefix:*  denotes all the qnames whose namespace
is given by the prefix; the type `* denotes all the qnames whose namespace
is the current default namespace.

X-element type: <tag attr>T where tag is either a qname (without the `),
an any-in-namespace type (without the `), or (T) where T is an x-type.
attr can be either a specification of fields as for records, or
(T) where T is an x-type.

Recursive types: they can be defined by regular OCaml recursive type
declarations, e.g.: 
  type t = {{s | `nil}} 
  and  s = {{(Int,t)}}
They can also be written online:  
  t with t = (s | `nil) and s = (Int,t)

Regular expression types: [R] where R is a regexp.
   R :=  R*    (Kleene star)
      |  R+    (Non-empty repetition)
      |  R?    (Optional)
      |  T     (One element)
      |  R R   (Sequence)
      |  R|R   (Alternation)
      |  (R)
      |  /T    (Guard, T applies to the current tail of the sequence)

Concatenation of types:
  T1 @ T2   (some linearity condition apply)

Record concatenation of types:
  T1 ++ T2


Predefined types:
  Any (all the values, can also be written _)
  Empty (no value)
  Int (all the integers)
  Int32 (corresponding to the range of int32 values)  
  Int64 (corresponding to the range of int64 values)
  Atom (all the qnames)
  String (all the Unicode strings)
  Latin1 (all the Unicode strings with only Latin1 characters)
  Latin1Char (all the characters of the Latin 1 character set)

Integer intervals:
  i  -- j   (integers between i and j included)
  ** -- j   (integers <= j)
  i  -- **  (integers >= i)

Character intervals:
  c -- d   (characters whose Unicode code point is between c and d)


X-PATTERNS:

X-patterns follow the same syntax as X-types. In particular,
any X-type is a valid X-pattern. In addition to X-types constructors, 
X-patterns can have:
- capture variables (lowercase OCaml identifiers);
- constant bindings (x := c) where x is a capture variable and c is 
  a literal x-constant (this pattern always succeeds and returns the 
  binding x->c).

In record x-patterns, it is possible to omit the =P part of a field.
The content is then replaced with the label name considered as
a capture variable. E.g.  { x y=P } is equivalent to { x=x y=P }.

It is also possible to add an "else" clause:
{ x = (a,_)|(a:=3) }
will accept any record with at-most the field x. If the content
is a pair, the capture variable a will be bound to its component;
otherwise, it is set to 3.

In regular expressions, it is possible to extract whole subsequences
with the notation  x::R, e.g.:

  [ _* x::Int+ _* ]

If the same sequence capture variable appear several times (or below a
repetition) in a regexp, it is bound to the concatenation of all matched
subsequences. E.g.:  [ (x::Int | _)* ] will extract in x all
the elements of type x in the sequence.

The regexp operators +,*,? are greedy by default (they match as long
as possible).  They admit non-gready variants +?,*?,??.



TYPE CHECKING:

X-types have a natural notion of subtyping: set inclusion.
Subsumption is automatic for x-expressions. For instance, a function
which accepts values of types T will also accept values of types T' if
T' is a subtype of T.

Implicit subsumption only applies to x-types. ML type constructors
are considered invariant for this subtyping relation. The explicit
ML subtyping construction is still available and behaves as expected
on x-types.

Most of the x-expression constructions have locally exact or very precise
typing.

Here is a short explanation on how type-checking works.

The OCaml type-checker is run first to detect which expressions are of
the new kind. A second ML type-checking pass is then done to introduce
subsumption steps where allowed. After these two passes, the x-type checker
obtains a data-flow summary of x-values in the whole compilation unit.
This is a directed graph. It must be made acyclic by putting enough
type annotation (either explicitly as a type-constraint, or in an
interface, or using ML data type declarations, etc...). Moreover,
the {:...:} constructions require the ML type to be fully known.

In the toplevel, type-checking is done after each phrase. Most
functions should then be annotated with their input x-type, otherwise
it is inferred as being {{Empty}} (sound, but not very useful
since the function cannot be applied).


TRANSLATION OF ML-TYPES:

Tuples (resp. records, functions) are translated to tuples (resp. records,
functions). Sum types are translated to union types; a constant constructor
A is translated to the qname `A; a non-constant constructor
A of t1 * ... * tn is translated to <A>[ T1 ... Tn ].
Closed polymorphic variants have the same translation.

int -> Int   (dynamic check when going back to ML)
int32 -> Int32
int64 -> Int64
string -> Latin1
t list -> [T*]
t array -> [T*]
unit -> []
char -> Latin1Char
{{T}} -> T

Unguarded recursives types are rejected. Recursive type
declarations (sums, products) are accepted.

A Failure exception is raised if a conversion from x-value to OCaml
would produce a value of a private type.


SUPPORT LIBRARY:

There is a companion support library called xml-support:
http://pauillac.inria.fr/~frisch/ocamlcduce/download/xml-support-0.0.4.tar.gz


OTHER MODIFICATIONS TO OCAML:

The num library is now part of the standard library.
The .cmi files are not compatible with those produced by OCaml.


AUTHOR:

The extension has been written by Alain Frisch. Parts of the CDuce
implementation, by the same author, have been reused.


TODO:
- examples
- the pretty-printer uses UTF-8 output for qualified names
- the pretty-printer don't print the definition of named x-types

