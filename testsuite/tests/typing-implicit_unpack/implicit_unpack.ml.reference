
# * * * * * * * * *                               val sort : (module Set.S with type elt = 'a) -> 'a list -> 'a list = <fun>
val make_set : ('a -> 'a -> int) -> (module Set.S with type elt = 'a) = <fun>
val sort_cmp : ('a -> 'a -> int) -> 'a list -> 'a list = <fun>
module type S = sig type t val x : t end
# val f : (module S with type t = int) -> int = <fun>
# Characters 6-37:
  let f (module M : S with type t = 'a) = M.x;; (* Error *)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: The type of this packed module contains variables:
(module S with type t = 'a)
# val f : (module S with type t = 'a) -> 'a = <fun>
# - : int = 1
#   type 'a s = { s : (module S with type t = 'a); }
# - : int s = {s = <module>}
# Characters 9-19:
  let f {s=(module M)} = M.x;; (* Error *)
           ^^^^^^^^^^
Error: The type of this packed module contains variables:
(module S with type t = 'a)
# val f : 'a s -> 'a = <fun>
#   type s = { s : (module S with type t = int); }
# val f : s -> int = <fun>
# val f : s -> s -> int = <fun>
#   module type S = sig val x : int end
# val f : (module S) -> int -> (module S) -> int = <fun>
# Characters 8-37:
  let m = (module struct let x = 3 end);; (* Error *)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: The signature for this packaged module couldn't be inferred.
# val m : (module S) = <module>
# - : int = 7
# - : int = 6
#   - : int = 3
# Characters 4-14:
  let (module M) = m;; (* Error: only allowed in [let .. in] *)
      ^^^^^^^^^^
Error: Modules are not allowed in this pattern.
# Characters 14-24:
  class c = let (module M) = m in object end;; (* Error again *)
                ^^^^^^^^^^
Error: Modules are not allowed in this pattern.
# module M : S
#   module type S' = sig val f : int -> int end
#       - : int = 6
#                                                                                                                         
Characters 1465-1465:
Error: Syntax error
# 
